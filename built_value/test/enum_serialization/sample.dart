import 'package:built_value/built_value.dart';
import 'package:built_value/serializer.dart';

class FruitEnum extends EnumClass {
  static const apple = FruitEnum._('apple');
  static const orange = FruitEnum._('orange');
  static const banana = FruitEnum._('banana');

  const FruitEnum._(String name) : super(name);

  static RightFruitEnumSerializer get rightSerializer {
    var fruitEnumSerializer = RightFruitEnumSerializer();
    if (!fruitEnumSerializer.validMapping()) {
      throw ArgumentError('Conflict in wireName');
    }
    return fruitEnumSerializer;
  }

  static WrongFruitEnumSerializer get wrongSerializer {
    var fruitEnumSerializer = WrongFruitEnumSerializer();
    if (!fruitEnumSerializer.validMapping()) {
      throw ArgumentError('Conflict in wireName');
    }
    return fruitEnumSerializer;
  }

  static FruitEnum valueOf(String name) => valueOf(name);
}

FruitEnum valueOf(String name) {
  switch (name) {
    case 'apple':
      return FruitEnum.apple;
    case 'orange':
      return FruitEnum.orange;
    case 'banana':
      return FruitEnum.banana;
    default:
      throw new ArgumentError(name);
  }
}

class RightFruitEnumSerializer extends EnumSerializer {
  //Autogenerated
  static const Map<String, Object> _toWire = const <String, Object>{
    'apple': 'apl',
    'orange': 'org',
    'banana': 'bnn',
  };

  //Autogenerated
  static const Map<Object, String> _fromWire = const <Object, String>{
    'apl': 'apple',
    'org': 'orange',
    'bnn': 'banana',
  };

  @override
  EnumClass deserialize(Serializers serializers, Object object,
          {FullType specifiedType = FullType.unspecified}) =>
      FruitEnum.valueOf(_fromWire[object] ?? (object is String ? object : ''));

  @override
  Object serializationKey(EnumClass object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Object serialize(Serializers serializers, EnumClass object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Iterable<Type> get types => const <Type>[FruitEnum];

  @override
  String get wireName => "fruity";

  @override
  bool validMapping() {
    for (var key in _toWire.keys) {
      for (var key2 in _toWire.keys) {
        if (key2 != key && _toWire[key] == _toWire[key2]) return false;
      }
    }
    return true;
  }
}

class WrongFruitEnumSerializer extends EnumSerializer {
  //Autogenerated
  static const Map<String, Object> _toWire = const <String, Object>{
    'apple': 'apl',
    'orange': 'apl',
    'banana': 'bnn',
  };

  //Autogenerated
  static const Map<Object, String> _fromWire = const <Object, String>{
    'apl': 'apple',
    'orange': 'orange',
    'bnn': 'banana',
  };

  @override
  EnumClass deserialize(Serializers serializers, Object object,
          {FullType specifiedType = FullType.unspecified}) =>
      FruitEnum.valueOf(_fromWire[object] ?? (object is String ? object : ''));

  @override
  Object serializationKey(EnumClass object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Object serialize(Serializers serializers, EnumClass object,
          {FullType specifiedType = FullType.unspecified}) =>
      _toWire[object.name] ?? object.name;

  @override
  Iterable<Type> get types => const <Type>[FruitEnum];

  @override
  String get wireName => "fruity";

  @override
  bool validMapping() {
    for (var key in _toWire.keys) {
      for (var key2 in _toWire.keys) {
        if (key2 != key && _toWire[key] == _toWire[key2]) return false;
      }
    }
    return true;
  }
}
